--- a/net/minecraft/server/Entity.java
+++ b/net/minecraft/server/Entity.java
@@ -6,8 +6,46 @@
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.Server;
+import org.bukkit.TravelAgent;
+import org.bukkit.block.BlockFace;
+import org.bukkit.entity.Hanging;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Painting;
+import org.bukkit.entity.Vehicle;
+import co.aikar.timings.SpigotTimings; // Spigot
+import co.aikar.timings.Timing; // Spigot
+import org.bukkit.event.entity.EntityCombustByEntityEvent;
+import org.bukkit.event.hanging.HangingBreakByEntityEvent;
+import org.bukkit.event.painting.PaintingBreakByEntityEvent;
+import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
+import org.bukkit.event.vehicle.VehicleEnterEvent;
+import org.bukkit.event.vehicle.VehicleExitEvent;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.event.entity.EntityCombustEvent;
+import org.bukkit.event.entity.EntityPortalEvent;
+import org.bukkit.plugin.PluginManager;
+// CraftBukkit end
+
+// PaperSpigot start
+import org.spigotmc.event.entity.EntityDismountEvent;
+// PaperSpigot end
+
 public abstract class Entity implements ICommandListener {
 
+    // CraftBukkit start
+    private static final int CURRENT_LEVEL = 2;
+    static boolean isLevelAtLeast(NBTTagCompound tag, int level) {
+        return tag.hasKey("Bukkit.updateLevel") && tag.getInt("Bukkit.updateLevel") >= level;
+    }
+    // CraftBukikt end
+
     private static final AxisAlignedBB a = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);
     private static int entityCount;
     private int id;
@@ -56,7 +94,7 @@
     public int ticksLived;
     public int maxFireTicks;
     public int fireTicks;
-    protected boolean inWater;
+    public boolean inWater; // Spigot - protected -> public // PAIL
     public int noDamageTicks;
     protected boolean justCreated;
     protected boolean fireProof;
@@ -64,13 +102,22 @@
     private double ar;
     private double as;
     public boolean ad;
-    public int ae;
-    public int af;
-    public int ag;
+    // PaperSpigot start - EAR: Fix bug with teleporting entities
+    public boolean isAddedToChunk() {
+        int chunkX = MathHelper.floor(locX / 16.0D);
+        int chunkY = MathHelper.floor(locY / 16.0D);
+        int chunkZ = MathHelper.floor(locZ / 16.0D);
+
+        return ad && getChunkX() == chunkX && getChunkY() == chunkY || getChunkZ() == chunkZ;
+    }
+    public int ae; public int getChunkX() { return ae; } // PAIL
+    public int af; public int getChunkY() { return af; } // PAIL
+    public int ag; public int getChunkZ() { return ag; } // PAIL
+    // PaperSpigot end
     public boolean ah;
     public boolean ai;
     public int portalCooldown;
-    protected boolean inPortal;
+    protected boolean ak;
     protected int al;
     public int dimension;
     protected BlockPosition an;
@@ -79,6 +126,20 @@
     private boolean invulnerable;
     protected UUID uniqueID;
     private final CommandObjectiveExecutor au;
+    public boolean valid; // CraftBukkit
+    public org.bukkit.projectiles.ProjectileSource projectileSource; // CraftBukkit - For projectiles only
+    public boolean forceExplosionKnockback; // CraftBukkit - SPIGOT-949
+    public boolean inUnloadedChunk = false; // PaperSpigot - Remove entities in unloaded chunks
+    public boolean loadChunks = false; // PaperSpigot - Entities can load chunks they move through and keep them loaded
+
+    // Spigot start
+    public Timing tickTimer = SpigotTimings.getEntityTimings(this); // Spigot
+    public final byte activationType = org.spigotmc.ActivationRange.initializeEntityActivationType(this);
+    public final boolean defaultActivationState;
+    public long activatedTick = Integer.MIN_VALUE;
+    public boolean fromMobSpawner;
+    public void inactiveTick() { }
+    // Spigot end
 
     public int getId() {
         return this.id;
@@ -108,14 +169,19 @@
         this.setPosition(0.0D, 0.0D, 0.0D);
         if (world != null) {
             this.dimension = world.worldProvider.getDimension();
+            // Spigot start
+            this.defaultActivationState = org.spigotmc.ActivationRange.initializeEntityActivationState(this, world.spigotConfig);
+        } else {
+            this.defaultActivationState = false;
         }
+        // Spigot end
 
         this.datawatcher = new DataWatcher(this);
-        this.datawatcher.a(0, (byte) 0);
-        this.datawatcher.a(1, (short) 300);
-        this.datawatcher.a(3, (byte) 0);
+        this.datawatcher.a(0, Byte.valueOf((byte) 0));
+        this.datawatcher.a(1, Short.valueOf((short) 300));
+        this.datawatcher.a(3, Byte.valueOf((byte) 0));
         this.datawatcher.a(2, "");
-        this.datawatcher.a(4, (byte) 0);
+        this.datawatcher.a(4, Byte.valueOf((byte) 0));
         this.h();
     }
 
@@ -152,6 +218,33 @@
     }
 
     protected void setYawPitch(float f, float f1) {
+        // CraftBukkit start - yaw was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(f)) {
+            f = 0;
+        }
+
+        if (f == Float.POSITIVE_INFINITY || f == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid yaw");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite yaw (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+            }
+            f = 0;
+        }
+
+        // pitch was sometimes set to NaN, so we need to set it back to 0
+        if (Float.isNaN(f1)) {
+            f1 = 0;
+        }
+
+        if (f1 == Float.POSITIVE_INFINITY || f1 == Float.NEGATIVE_INFINITY) {
+            if (this instanceof EntityPlayer) {
+                this.world.getServer().getLogger().warning(this.getName() + " was caught trying to crash the server with an invalid pitch");
+                ((CraftPlayer) this.getBukkitEntity()).kickPlayer("Infinite pitch (Hacking?)"); //Spigot "Nope" -> Descriptive reason
+            }
+            f1 = 0;
+        }
+        // CraftBukkit end
+
         this.yaw = f % 360.0F;
         this.pitch = f1 % 360.0F;
     }
@@ -170,6 +263,13 @@
         this.K();
     }
 
+    /**
+     * PaperSpigot - Checks if the feature is enabled and the entity is above the nether world bedrock height
+     */
+    private boolean paperNetherCheck() {
+        return this.world.paperSpigotConfig.netherVoidTopDamage && this.world.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this.locY >= 128.0D;
+    }
+
     public void K() {
         this.world.methodProfiler.a("entityBaseTick");
         if (this.vehicle != null && this.vehicle.dead) {
@@ -187,8 +287,8 @@
             MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
             int i = this.L();
 
-            if (this.inPortal) {
-                if (minecraftserver.getAllowNether()) {
+            if (this.ak) {
+                if (true || minecraftserver.getAllowNether()) { // CraftBukkit
                     if (this.vehicle == null && this.al++ >= i) {
                         this.al = i;
                         this.portalCooldown = this.aq();
@@ -203,7 +303,7 @@
                         this.c(b0);
                     }
 
-                    this.inPortal = false;
+                    this.ak = false;
                 }
             } else {
                 if (this.al > 0) {
@@ -246,7 +346,7 @@
             this.fallDistance *= 0.5F;
         }
 
-        if (this.locY < -64.0D) {
+        if (this.locY < -64.0D || paperNetherCheck()) { // PaperSpigot - Configurable top-of-nether void damage
             this.O();
         }
 
@@ -265,6 +365,27 @@
     protected void burnFromLava() {
         if (!this.fireProof) {
             this.damageEntity(DamageSource.LAVA, 4.0F);
+
+            // CraftBukkit start - Fallen in lava TODO: this event spams!
+            if (this instanceof EntityLiving) {
+                if (fireTicks <= 0) {
+                    // not on fire yet
+                    // TODO: shouldn't be sending null for the block
+                    org.bukkit.block.Block damager = null; // ((WorldServer) this.l).getWorld().getBlockAt(i, j, k);
+                    org.bukkit.entity.Entity damagee = this.getBukkitEntity();
+                    EntityCombustEvent combustEvent = new org.bukkit.event.entity.EntityCombustByBlockEvent(damager, damagee, 15);
+                    this.world.getServer().getPluginManager().callEvent(combustEvent);
+
+                    if (!combustEvent.isCancelled()) {
+                        this.setOnFire(combustEvent.getDuration());
+                    }
+                } else {
+                    // This will be called every single tick the entity is in lava, so don't throw an event
+                    this.setOnFire(15);
+                }
+                return;
+            }
+            // CraftBukkit end - we also don't throw an event unless the object in lava is living, to save on some event calls
             this.setOnFire(15);
         }
     }
@@ -297,11 +418,40 @@
         return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
     }
 
+    /**
+     * PaperSpigot - Load surrounding chunks the entity is moving through
+     */
+    public void loadChunks() {
+        for (int cx = (int) locX >> 4; cx <= (int) (locX + motX) >> 4; ++cx) {
+            for (int cz = (int) locZ >> 4; cz <= (int) (locZ + motZ) >> 4; ++cz) {
+                ((ChunkProviderServer) world.chunkProvider).getChunkAt(cx, cz);
+            }
+        }
+    }
+
+
     public void move(double d0, double d1, double d2) {
+        if (this.loadChunks) loadChunks(); // PaperSpigot - Load chunks
         if (this.noclip) {
             this.a(this.getBoundingBox().c(d0, d1, d2));
             this.recalcPosition();
         } else {
+            // CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
+            try {
+                this.checkBlockCollisions();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Checking entity block collision");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being checked for collision");
+
+                this.appendEntityCrashDetails(crashreportsystemdetails);
+                throw new ReportedException(crashreport);
+            }
+            // Check if we're moving
+            if (d0 == 0 && d1 == 0 && d2 == 0 && this.vehicle == null && this.passenger == null) {
+                return;
+            }
+            // CraftBukkit end
             this.world.methodProfiler.a("move");
             double d3 = this.locX;
             double d4 = this.locY;
@@ -365,7 +515,16 @@
                 }
             }
 
-            List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
+            // TacoSpigot start - do axis by axis scan if the entity is travelling a large area
+            AxisAlignedBB totalArea = this.getBoundingBox().a(d0, d1, d2);
+            double xLength = totalArea.d - totalArea.a;
+            double yLength = totalArea.e - totalArea.b;
+            double zLength = totalArea.f - totalArea.c;
+            boolean axisScan = this.world.tacoSpigotConfig.optimizeTntMovement && xLength * yLength * zLength > 10;
+
+            List list = this.world.getCubes(this, axisScan ? this.getBoundingBox().a(0, d1, 0) : totalArea);
+            // TacoSpigot end
+
             AxisAlignedBB axisalignedbb = this.getBoundingBox();
 
             AxisAlignedBB axisalignedbb1;
@@ -380,17 +539,41 @@
             AxisAlignedBB axisalignedbb2;
             Iterator iterator1;
 
+            if(this.world.tacoSpigotConfig.fixEastWest && Math.abs(d0) > Math.abs(d2)) { //TacoSpigot - fix east/west cannoning by calculating the z movement before x if the x velocity is greater
+            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
+
+            for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
+                axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+            }
+
+                this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+
+                if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(d0, 0, 0)); // TacoSpigot - get x axis blocks
+
+                for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
+                    axisalignedbb2 = (AxisAlignedBB) iterator1.next();
+                }
+
+                this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
+
+            } else {
+            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(d0, 0, 0)); // TacoSpigot - get x axis blocks
+
             for (iterator1 = list.iterator(); iterator1.hasNext(); d0 = axisalignedbb2.a(this.getBoundingBox(), d0)) {
                 axisalignedbb2 = (AxisAlignedBB) iterator1.next();
             }
 
             this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
 
+            if(axisScan) list = this.world.getCubes(this, this.getBoundingBox().a(0, 0, d2)); // TacoSpigot - get z axis blocks
+
             for (iterator1 = list.iterator(); iterator1.hasNext(); d2 = axisalignedbb2.c(this.getBoundingBox(), d2)) {
                 axisalignedbb2 = (AxisAlignedBB) iterator1.next();
             }
 
             this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+            }
+
             if (this.S > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
                 double d10 = d0;
                 double d11 = d1;
@@ -522,6 +705,26 @@
                 block.a(this.world, this);
             }
 
+            // CraftBukkit start
+            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX), MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
+
+                if (d6 > d0) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (d6 < d0) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (d8 > d2) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (d8 < d2) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                world.getServer().getPluginManager().callEvent(event);
+            }
+            // CraftBukkit end
+
             if (this.s_() && !flag && this.vehicle == null) {
                 double d21 = this.locX - d3;
                 double d22 = this.locY - d4;
@@ -532,7 +735,7 @@
                 }
 
                 if (block != null && this.onGround) {
-                    block.a(this.world, blockposition, this);
+                    // block.a(this.world, blockposition, this); // CraftBukkit moved down
                 }
 
                 this.M = (float) ((double) this.M + (double) MathHelper.sqrt(d21 * d21 + d23 * d23) * 0.6D);
@@ -550,9 +753,12 @@
                     }
 
                     this.a(blockposition, block);
+                    block.a(this.world, blockposition, this); // CraftBukkit moved from above
                 }
             }
 
+            // CraftBukkit start - Move to the top of the method
+            /*
             try {
                 this.checkBlockCollisions();
             } catch (Throwable throwable) {
@@ -562,6 +768,8 @@
                 this.appendEntityCrashDetails(crashreportsystemdetails);
                 throw new ReportedException(crashreport);
             }
+            */
+            // CraftBukkit end
 
             boolean flag2 = this.U();
 
@@ -569,7 +777,16 @@
                 this.burn(1);
                 if (!flag2) {
                     ++this.fireTicks;
-                    if (this.fireTicks == 0) {
+                    // CraftBukkit start - Not on fire yet
+                    if (this.fireTicks <= 0) { // Only throw events on the first combust, otherwise it spams
+                        EntityCombustEvent event = new EntityCombustEvent(getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            setOnFire(event.getDuration());
+                        }
+                    } else {
+                        // CraftBukkit end
                         this.setOnFire(8);
                     }
                 }
@@ -675,7 +892,7 @@
         return null;
     }
 
-    protected void burn(int i) {
+    protected void burn(float i) { // CraftBukkit - int -> float
         if (!this.fireProof) {
             this.damageEntity(DamageSource.FIRE, (float) i);
         }
@@ -727,20 +944,20 @@
         this.makeSound(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
         float f1 = (float) MathHelper.floor(this.getBoundingBox().b);
 
+        int i;
         float f2;
         float f3;
-        int i;
 
         for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
             f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
             f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.addParticle(EnumParticle.WATER_BUBBLE, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY - (double) (this.random.nextFloat() * 0.2F), this.motZ);
+            this.world.addParticle(EnumParticle.WATER_BUBBLE, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY - (double) (this.random.nextFloat() * 0.2F), this.motZ, new int[0]);
         }
 
         for (i = 0; (float) i < 1.0F + this.width * 20.0F; ++i) {
             f2 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
             f3 = (this.random.nextFloat() * 2.0F - 1.0F) * this.width;
-            this.world.addParticle(EnumParticle.WATER_SPLASH, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY, this.motZ);
+            this.world.addParticle(EnumParticle.WATER_SPLASH, this.locX + (double) f2, (double) (f1 + 1.0F), this.locZ + (double) f3, this.motX, this.motY, this.motZ, new int[0]);
         }
 
     }
@@ -761,7 +978,7 @@
         Block block = iblockdata.getBlock();
 
         if (block.b() != -1) {
-            this.world.addParticle(EnumParticle.BLOCK_CRACK, this.locX + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, this.getBoundingBox().b + 0.1D, this.locZ + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, -this.motX * 4.0D, 1.5D, -this.motZ * 4.0D, Block.getCombinedId(iblockdata));
+            this.world.addParticle(EnumParticle.BLOCK_CRACK, this.locX + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, this.getBoundingBox().b + 0.1D, this.locZ + ((double) this.random.nextFloat() - 0.5D) * (double) this.width, -this.motX * 4.0D, 1.5D, -this.motZ * 4.0D, new int[] { Block.getCombinedId(iblockdata)});
         }
 
     }
@@ -818,6 +1035,13 @@
     }
 
     public void spawnIn(World world) {
+        // CraftBukkit start
+        if (world == null) {
+            die();
+            this.world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
+            return;
+        }
+        // CraftBukkit end
         this.world = world;
     }
 
@@ -896,6 +1120,7 @@
 
     public void d(EntityHuman entityhuman) {}
 
+    int numCollisions = 0; // Spigot
     public void collide(Entity entity) {
         if (entity.passenger != this && entity.vehicle != this) {
             if (!entity.noclip && !this.noclip) {
@@ -1008,9 +1233,21 @@
 
     public void e(NBTTagCompound nbttagcompound) {
         try {
-            nbttagcompound.set("Pos", this.a(this.locX, this.locY, this.locZ));
-            nbttagcompound.set("Motion", this.a(this.motX, this.motY, this.motZ));
-            nbttagcompound.set("Rotation", this.a(this.yaw, this.pitch));
+            nbttagcompound.set("Pos", this.a(new double[] { this.locX, this.locY, this.locZ}));
+            nbttagcompound.set("Motion", this.a(new double[] { this.motX, this.motY, this.motZ}));
+
+            // CraftBukkit start - Checking for NaN pitch/yaw and resetting to zero
+            // TODO: make sure this is the best way to address this.
+            if (Float.isNaN(this.yaw)) {
+                this.yaw = 0;
+            }
+
+            if (Float.isNaN(this.pitch)) {
+                this.pitch = 0;
+            }
+            // CraftBukkit end
+
+            nbttagcompound.set("Rotation", this.a(new float[] { this.yaw, this.pitch}));
             nbttagcompound.setFloat("FallDistance", this.fallDistance);
             nbttagcompound.setShort("Fire", (short) this.fireTicks);
             nbttagcompound.setShort("Air", (short) this.getAirTicks());
@@ -1020,6 +1257,12 @@
             nbttagcompound.setInt("PortalCooldown", this.portalCooldown);
             nbttagcompound.setLong("UUIDMost", this.getUniqueID().getMostSignificantBits());
             nbttagcompound.setLong("UUIDLeast", this.getUniqueID().getLeastSignificantBits());
+            // CraftBukkit start
+            nbttagcompound.setLong("WorldUUIDLeast", this.world.getDataManager().getUUID().getLeastSignificantBits());
+            nbttagcompound.setLong("WorldUUIDMost", this.world.getDataManager().getUUID().getMostSignificantBits());
+            nbttagcompound.setInt("Bukkit.updateLevel", CURRENT_LEVEL);
+            nbttagcompound.setInt("Spigot.ticksLived", this.ticksLived);
+            // CraftBukkit end
             if (this.getCustomName() != null && this.getCustomName().length() > 0) {
                 nbttagcompound.setString("CustomName", this.getCustomName());
                 nbttagcompound.setBoolean("CustomNameVisible", this.getCustomNameVisible());
@@ -1057,6 +1300,8 @@
             this.motX = nbttaglist1.d(0);
             this.motY = nbttaglist1.d(1);
             this.motZ = nbttaglist1.d(2);
+
+            /* CraftBukkit start - Moved section down
             if (Math.abs(this.motX) > 10.0D) {
                 this.motX = 0.0D;
             }
@@ -1068,6 +1313,7 @@
             if (Math.abs(this.motZ) > 10.0D) {
                 this.motZ = 0.0D;
             }
+            // CraftBukkit end */
 
             this.lastX = this.P = this.locX = nbttaglist.d(0);
             this.lastY = this.Q = this.locY = nbttaglist.d(1);
@@ -1103,6 +1349,60 @@
                 this.setPosition(this.locX, this.locY, this.locZ);
             }
 
+            // CraftBukkit start
+            if (this instanceof EntityLiving) {
+                EntityLiving entity = (EntityLiving) this;
+
+                this.ticksLived = nbttagcompound.getInt("Spigot.ticksLived");
+
+                // Reset the persistence for tamed animals
+                if (entity instanceof EntityTameableAnimal && !isLevelAtLeast(nbttagcompound, 2) && !nbttagcompound.getBoolean("PersistenceRequired")) {
+                    EntityInsentient entityinsentient = (EntityInsentient) entity;
+                    entityinsentient.persistent = !entityinsentient.isTypeNotPersistent();
+                }
+            }
+            // CraftBukkit end
+
+            // CraftBukkit start - Exempt Vehicles from notch's sanity check
+            if (!(getBukkitEntity() instanceof Vehicle)) {
+                if (Math.abs(this.motX) > 10.0D) {
+                    this.motX = 0.0D;
+                }
+
+                if (Math.abs(this.motY) > 10.0D) {
+                    this.motY = 0.0D;
+                }
+
+                if (Math.abs(this.motZ) > 10.0D) {
+                    this.motZ = 0.0D;
+                }
+            }
+            // CraftBukkit end
+
+            // CraftBukkit start - Reset world
+            if (this instanceof EntityPlayer) {
+                Server server = Bukkit.getServer();
+                org.bukkit.World bworld = null;
+
+                // TODO: Remove World related checks, replaced with WorldUID
+                String worldName = nbttagcompound.getString("world");
+
+                if (nbttagcompound.hasKey("WorldUUIDMost") && nbttagcompound.hasKey("WorldUUIDLeast")) {
+                    UUID uid = new UUID(nbttagcompound.getLong("WorldUUIDMost"), nbttagcompound.getLong("WorldUUIDLeast"));
+                    bworld = server.getWorld(uid);
+                } else {
+                    bworld = server.getWorld(worldName);
+                }
+
+                if (bworld == null) {
+                    EntityPlayer entityPlayer = (EntityPlayer) this;
+                    bworld = ((org.bukkit.craftbukkit.CraftServer) server).getServer().getWorldServer(entityPlayer.dimension).getWorld();
+                }
+
+                spawnIn(bworld == null? null : ((CraftWorld) bworld).getHandle());
+            }
+            // CraftBukkit end
+
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being loaded");
@@ -1164,6 +1464,12 @@
 
     public EntityItem a(ItemStack itemstack, float f) {
         if (itemstack.count != 0 && itemstack.getItem() != null) {
+            // CraftBukkit start - Capture drops for death event
+            if (this instanceof EntityLiving && ((EntityLiving) this).drops != null) {
+                ((EntityLiving) this).drops.add(org.bukkit.craftbukkit.inventory.CraftItemStack.asBukkitCopy(itemstack));
+                return null;
+            }
+            // CraftBukkit end
             EntityItem entityitem = new EntityItem(this.world, this.locX, this.locY + (double) f, this.locZ, itemstack);
 
             entityitem.p();
@@ -1190,7 +1496,7 @@
                 int l = MathHelper.floor(this.locZ + (double) (((float) ((i >> 2) % 2) - 0.5F) * this.width * 0.8F));
 
                 if (blockposition_mutableblockposition.getX() != k || blockposition_mutableblockposition.getY() != j || blockposition_mutableblockposition.getZ() != l) {
-                    blockposition_mutableblockposition.setValues(k, j, l);
+                    blockposition_mutableblockposition.c(k, j, l);
                     if (this.world.getType(blockposition_mutableblockposition).getBlock().w()) {
                         return true;
                     }
@@ -1277,17 +1583,87 @@
         return (double) this.length * 0.75D;
     }
 
+    // CraftBukkit start
+    protected CraftEntity bukkitEntity;
+
+    public CraftEntity getBukkitEntity() {
+        if (bukkitEntity == null) {
+            bukkitEntity = CraftEntity.getEntity(world.getServer(), this);
+        }
+        return bukkitEntity;
+    }
+
     public void mount(Entity entity) {
+        Entity originalVehicle = this.vehicle;
+        Entity originalPassenger = this.vehicle == null ? null : this.vehicle.passenger;
+        PluginManager pluginManager = Bukkit.getPluginManager();
+        getBukkitEntity(); // make sure bukkitEntity is initialised
+        // CraftBukkit end
         this.ar = 0.0D;
         this.as = 0.0D;
         if (entity == null) {
             if (this.vehicle != null) {
+                // CraftBukkit start
+                if ((this.bukkitEntity instanceof LivingEntity) && (this.vehicle.getBukkitEntity() instanceof Vehicle)) {
+                    VehicleExitEvent event = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
+                    pluginManager.callEvent(event);
+
+                    if (event.isCancelled() || vehicle != originalVehicle) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                // PaperSpigot start - make EntityDismountEvent cancellable
+                EntityDismountEvent dismountEvent = new EntityDismountEvent(this.getBukkitEntity(), this.vehicle.getBukkitEntity()); // Spigot
+                pluginManager.callEvent(dismountEvent);
+                if (dismountEvent.isCancelled()) return;
+                // PaperSpigot end
                 this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
                 this.vehicle.passenger = null;
             }
 
             this.vehicle = null;
         } else {
+            // CraftBukkit start
+            if ((this.bukkitEntity instanceof LivingEntity) && (entity.getBukkitEntity() instanceof Vehicle) && entity.world.isChunkLoaded((int) entity.locX >> 4, (int) entity.locZ >> 4, true)) {
+                // It's possible to move from one vehicle to another.  We need to check if they're already in a vehicle, and fire an exit event if they are.
+                VehicleExitEvent exitEvent = null;
+                if (this.vehicle != null && this.vehicle.getBukkitEntity() instanceof Vehicle) {
+                    exitEvent = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
+                    pluginManager.callEvent(exitEvent);
+
+                    if (exitEvent.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
+                        return;
+                    }
+                }
+
+                VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.bukkitEntity);
+                pluginManager.callEvent(event);
+
+                // If a plugin messes with the vehicle or the vehicle's passenger
+                if (event.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
+                    // If we only cancelled the enterevent then we need to put the player in a decent position.
+                    if (exitEvent != null && this.vehicle == originalVehicle && this.vehicle != null && this.vehicle.passenger == originalPassenger) {
+                        this.setPositionRotation(this.vehicle.locX, this.vehicle.getBoundingBox().b + (double) this.vehicle.length, this.vehicle.locZ, this.yaw, this.pitch);
+                        this.vehicle.passenger = null;
+                        this.vehicle = null;
+                    }
+                    return;
+                }
+            }
+            // CraftBukkit end
+            // Spigot Start
+            if ( entity.world.isChunkLoaded( (int) entity.locX >> 4, (int) entity.locZ >> 4, true ) )
+            {
+                org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent( this.getBukkitEntity(), entity.getBukkitEntity() );
+                pluginManager.callEvent( event );
+                if ( event.isCancelled() )
+                {
+                    return;
+                }
+            }
+            // Spigot End
+
             if (this.vehicle != null) {
                 this.vehicle.passenger = null;
             }
@@ -1330,7 +1706,7 @@
                 this.ap = shapedetector_shapedetectorcollection.b();
             }
 
-            this.inPortal = true;
+            this.ak = true;
         }
     }
 
@@ -1390,9 +1766,9 @@
         byte b0 = this.datawatcher.getByte(0);
 
         if (flag) {
-            this.datawatcher.watch(0, (byte) (b0 | 1 << i));
+            this.datawatcher.watch(0, Byte.valueOf((byte) (b0 | 1 << i)));
         } else {
-            this.datawatcher.watch(0, (byte) (b0 & ~(1 << i)));
+            this.datawatcher.watch(0, Byte.valueOf((byte) (b0 & ~(1 << i))));
         }
 
     }
@@ -1402,14 +1778,53 @@
     }
 
     public void setAirTicks(int i) {
-        this.datawatcher.watch(1, (short) i);
+        this.datawatcher.watch(1, Short.valueOf((short) i));
     }
 
     public void onLightningStrike(EntityLightning entitylightning) {
-        this.damageEntity(DamageSource.LIGHTNING, 5.0F);
+        // CraftBukkit start
+        final org.bukkit.entity.Entity thisBukkitEntity = this.getBukkitEntity();
+        final org.bukkit.entity.Entity stormBukkitEntity = entitylightning.getBukkitEntity();
+        final PluginManager pluginManager = Bukkit.getPluginManager();
+
+        if (thisBukkitEntity instanceof Hanging) {
+            HangingBreakByEntityEvent hangingEvent = new HangingBreakByEntityEvent((Hanging) thisBukkitEntity, stormBukkitEntity);
+            PaintingBreakByEntityEvent paintingEvent = null;
+
+            if (thisBukkitEntity instanceof Painting) {
+                paintingEvent = new PaintingBreakByEntityEvent((Painting) thisBukkitEntity, stormBukkitEntity);
+            }
+
+            pluginManager.callEvent(hangingEvent);
+
+            if (paintingEvent != null) {
+                paintingEvent.setCancelled(hangingEvent.isCancelled());
+                pluginManager.callEvent(paintingEvent);
+            }
+
+            if (hangingEvent.isCancelled() || (paintingEvent != null && paintingEvent.isCancelled())) {
+                return;
+            }
+        }
+
+        if (this.fireProof) {
+            return;
+        }
+        CraftEventFactory.entityDamage = entitylightning;
+        if (!this.damageEntity(DamageSource.LIGHTNING, 5.0F)) {
+            CraftEventFactory.entityDamage = null;
+            return;
+        }
+        // CraftBukkit end
         ++this.fireTicks;
         if (this.fireTicks == 0) {
-            this.setOnFire(8);
+            // CraftBukkit start - Call a combust event when lightning strikes
+            EntityCombustByEntityEvent entityCombustEvent = new EntityCombustByEntityEvent(stormBukkitEntity, thisBukkitEntity, 8);
+            pluginManager.callEvent(entityCombustEvent);
+            if (!entityCombustEvent.isCancelled()) {
+                this.setOnFire(entityCombustEvent.getDuration());
+            }
+            // CraftBukkit end
         }
 
     }
@@ -1524,7 +1939,7 @@
     }
 
     public String toString() {
-        return String.format("%s['%s'/%d, l='%s', x=%.2f, y=%.2f, z=%.2f]", this.getClass().getSimpleName(), this.getName(), this.id, this.world == null ? "~NULL~" : this.world.getWorldData().getName(), this.locX, this.locY, this.locZ);
+        return String.format("%s[\'%s\'/%d, l=\'%s\', x=%.2f, y=%.2f, z=%.2f]", new Object[] { this.getClass().getSimpleName(), this.getName(), Integer.valueOf(this.id), this.world == null ? "~NULL~" : this.world.getWorldData().getName(), Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)});
     }
 
     public boolean isInvulnerable(DamageSource damagesource) {
@@ -1550,32 +1965,83 @@
         if (!this.world.isClientSide && !this.dead) {
             this.world.methodProfiler.a("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
-            int j = this.dimension;
-            WorldServer worldserver = minecraftserver.getWorldServer(j);
-            WorldServer worldserver1 = minecraftserver.getWorldServer(i);
+            // CraftBukkit start - Move logic into new function "teleportToLocation"
+            // int j = this.dimension;
+            // WorldServer worldserver = minecraftserver.getWorldServer(j);
+            // WorldServer worldserver1 = minecraftserver.getWorldServer(i);
+            WorldServer exitWorld = null;
+            if (this.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // Plugins must specify exit from custom Bukkit worlds
+                // Only target existing worlds (compensate for allow-nether/allow-end as false)
+                for (WorldServer world : minecraftserver.worlds) {
+                    if (world.dimension == i) {
+                        exitWorld = world;
+                    }
+                }
+            }
+
+            Location enter = this.getBukkitEntity().getLocation();
+            Location exit = exitWorld != null ? minecraftserver.getPlayerList().calculateTarget(enter, minecraftserver.getWorldServer(i)) : null;
+            boolean useTravelAgent = exitWorld != null && !(this.dimension == 1 && exitWorld.dimension == 1); // don't use agent for custom worlds or return from THE_END
+
+            TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getTravelAgent() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+            EntityPortalEvent event = new EntityPortalEvent(this.getBukkitEntity(), enter, exit, agent);
+            event.useTravelAgent(useTravelAgent);
+            event.getEntity().getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled() || event.getTo() == null || event.getTo().getWorld() == null || !this.isAlive()) {
+                return;
+            }
+            exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+            this.teleportTo(exit, true);
+        }
+    }
+
+    public void teleportTo(Location exit, boolean portal) {
+        if (true) {
+            WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
+            WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+            int i = worldserver1.dimension;
+            // CraftBukkit end
 
             this.dimension = i;
+            /* CraftBukkit start - TODO: Check if we need this
             if (j == 1 && i == 1) {
                 worldserver1 = minecraftserver.getWorldServer(0);
                 this.dimension = 0;
             }
+            // CraftBukkit end */
 
             this.world.kill(this);
             this.dead = false;
             this.world.methodProfiler.a("reposition");
-            minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
+            // CraftBukkit start - Ensure chunks are loaded in case TravelAgent is not used which would initially cause chunks to load during find/create
+            // minecraftserver.getPlayerList().changeWorld(this, j, worldserver, worldserver1);
+            boolean before = worldserver1.chunkProviderServer.forceChunkLoad;
+            worldserver1.chunkProviderServer.forceChunkLoad = true;
+            worldserver1.getMinecraftServer().getPlayerList().repositionEntity(this, exit, portal);
+            worldserver1.chunkProviderServer.forceChunkLoad = before;
+            // CraftBukkit end
             this.world.methodProfiler.c("reloading");
             Entity entity = EntityTypes.createEntityByName(EntityTypes.b(this), worldserver1);
 
             if (entity != null) {
                 entity.n(this);
+                /* CraftBukkit start - We need to do this...
                 if (j == 1 && i == 1) {
                     BlockPosition blockposition = this.world.r(worldserver1.getSpawn());
 
                     entity.setPositionRotation(blockposition, entity.yaw, entity.pitch);
                 }
+                // CraftBukkit end */
 
                 worldserver1.addEntity(entity);
+                // CraftBukkit start - Forward the CraftEntity to the new entity
+                this.getBukkitEntity().setHandle(entity);
+                entity.bukkitEntity = this.getBukkitEntity();
+
+                if (this instanceof EntityInsentient) {
+                    ((EntityInsentient)this).unleash(true, false); // Unleash to prevent duping of leads.
+                }
+                // CraftBukkit end
             }
 
             this.dead = true;
@@ -1611,7 +2077,7 @@
     }
 
     public void appendEntityCrashDetails(CrashReportSystemDetails crashreportsystemdetails) {
-        crashreportsystemdetails.a("Entity Type", new Callable<String>() {
+        crashreportsystemdetails.a("Entity Type", new Callable() {
             public String a() throws Exception {
                 return EntityTypes.b(Entity.this) + " (" + Entity.this.getClass().getCanonicalName() + ")";
             }
@@ -1620,8 +2086,8 @@
                 return this.a();
             }
         });
-        crashreportsystemdetails.a("Entity ID", (Object) this.id);
-        crashreportsystemdetails.a("Entity Name", new Callable<String>() {
+        crashreportsystemdetails.a("Entity ID", (Object) Integer.valueOf(this.id));
+        crashreportsystemdetails.a("Entity Name", new Callable() {
             public String a() throws Exception {
                 return Entity.this.getName();
             }
@@ -1630,10 +2096,10 @@
                 return this.a();
             }
         });
-        crashreportsystemdetails.a("Entity's Exact location", (Object) String.format("%.2f, %.2f, %.2f", this.locX, this.locY, this.locZ));
-        crashreportsystemdetails.a("Entity's Block location", (Object) CrashReportSystemDetails.a((double) MathHelper.floor(this.locX), (double) MathHelper.floor(this.locY), (double) MathHelper.floor(this.locZ)));
-        crashreportsystemdetails.a("Entity's Momentum", (Object) String.format("%.2f, %.2f, %.2f", this.motX, this.motY, this.motZ));
-        crashreportsystemdetails.a("Entity's Rider", new Callable<String>() {
+        crashreportsystemdetails.a("Entity\'s Exact location", (Object) String.format("%.2f, %.2f, %.2f", new Object[] { Double.valueOf(this.locX), Double.valueOf(this.locY), Double.valueOf(this.locZ)}));
+        crashreportsystemdetails.a("Entity\'s Block location", (Object) CrashReportSystemDetails.a((double) MathHelper.floor(this.locX), (double) MathHelper.floor(this.locY), (double) MathHelper.floor(this.locZ)));
+        crashreportsystemdetails.a("Entity\'s Momentum", (Object) String.format("%.2f, %.2f, %.2f", new Object[] { Double.valueOf(this.motX), Double.valueOf(this.motY), Double.valueOf(this.motZ)}));
+        crashreportsystemdetails.a("Entity\'s Rider", new Callable() {
             public String a() throws Exception {
                 return Entity.this.passenger.toString();
             }
@@ -1642,7 +2108,7 @@
                 return this.a();
             }
         });
-        crashreportsystemdetails.a("Entity's Vehicle", new Callable<String>() {
+        crashreportsystemdetails.a("Entity\'s Vehicle", new Callable() {
             public String a() throws Exception {
                 return Entity.this.vehicle.toString();
             }
@@ -1670,6 +2136,11 @@
     }
 
     public void setCustomName(String s) {
+        // CraftBukkit start - Add a sane limit for name length
+        if (s.length() > 256) {
+            s = s.substring(0, 256);
+        }
+        // CraftBukkit end
         this.datawatcher.watch(2, s);
     }
 
@@ -1721,7 +2192,26 @@
     }
 
     public void a(AxisAlignedBB axisalignedbb) {
-        this.boundingBox = axisalignedbb;
+        // CraftBukkit start - block invalid bounding boxes
+        double a = axisalignedbb.a,
+                b = axisalignedbb.b,
+                c = axisalignedbb.c,
+                d = axisalignedbb.d,
+                e = axisalignedbb.e,
+                f = axisalignedbb.f;
+        double len = axisalignedbb.d - axisalignedbb.a;
+        if (len < 0) d = a;
+        if (len > 64) d = a + 64.0;
+
+        len = axisalignedbb.e - axisalignedbb.b;
+        if (len < 0) e = b;
+        if (len > 64) e = b + 64.0;
+
+        len = axisalignedbb.f - axisalignedbb.c;
+        if (len < 0) f = c;
+        if (len > 64) f = c + 64.0;
+        this.boundingBox = new AxisAlignedBB(a, b, c, d, e, f);
+        // CraftBukkit end
     }
 
     public float getHeadHeight() {
