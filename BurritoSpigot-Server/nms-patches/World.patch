--- a/net/minecraft/server/World.java
+++ b/net/minecraft/server/World.java
@@ -2,30 +2,71 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
+import org.bukkit.Bukkit;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.craftbukkit.util.LongHashSet;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.generator.ChunkGenerator;
+import co.aikar.timings.SpigotTimings;
+
+import java.util.*;
 import java.util.concurrent.Callable;
 
+// PaperSpigot start
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+// PaperSpigot end
+
+// CraftBukkit start
+// CraftBukkit end
+
 public abstract class World implements IBlockAccess {
 
     private int a = 63;
     protected boolean e;
-    public final List<Entity> entityList = Lists.newArrayList();
-    protected final List<Entity> g = Lists.newArrayList();
-    public final List<TileEntity> h = Lists.newArrayList();
+    // Spigot start - guard entity list from removals
+    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    {
+        @Override
+        public Entity remove(int index)
+        {
+            guard();
+            return super.remove( index );
+        }
+
+        @Override
+        public boolean remove(Object o)
+        {
+            guard();
+            return super.remove( o );
+        }
+
+        private void guard()
+        {
+            if ( guardEntityList )
+            {
+                throw new java.util.ConcurrentModificationException();
+            }
+        }
+    };
+    // Spigot end
+    protected final Set<Entity> g = Sets.newHashSet(); // Paper
+    //public final List<TileEntity> h = Lists.newArrayList(); // PaperSpigot - Remove unused list
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
-    private final List<TileEntity> c = Lists.newArrayList();
+    private final Set<TileEntity> c = Sets.newHashSet(); // Paper
     public final List<EntityHuman> players = Lists.newArrayList();
     public final List<Entity> k = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap<>();
+    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
     private long d = 16777215L;
     private int I;
     protected int m = (new Random()).nextInt();
@@ -36,27 +77,121 @@
     protected float r;
     private int J;
     public final Random random = new Random();
-    public final WorldProvider worldProvider;
+    public WorldProvider worldProvider; // CraftBukkit - remove final
     protected List<IWorldAccess> u = Lists.newArrayList();
     protected IChunkProvider chunkProvider;
     protected final IDataManager dataManager;
-    protected WorldData worldData;
+    public WorldData worldData; // CraftBukkit - public
     protected boolean isLoading;
-    protected PersistentCollection worldMaps;
+    public PersistentCollection worldMaps; // CraftBukkit - public
     protected PersistentVillage villages;
     public final MethodProfiler methodProfiler;
     private final Calendar K = Calendar.getInstance();
-    protected Scoreboard scoreboard = new Scoreboard();
+    public Scoreboard scoreboard = new Scoreboard(); // CraftBukkit - public
     public final boolean isClientSide;
-    protected Set<ChunkCoordIntPair> chunkTickList = Sets.newHashSet();
+    // CraftBukkit - longhashset
+    // protected LongHashSet chunkTickList = new LongHashSet(); // Spigot
     private int L;
-    protected boolean allowMonsters;
-    protected boolean allowAnimals;
+    public boolean allowMonsters; // CraftBukkit - public
+    public boolean allowAnimals; // CraftBukkit - public
     private boolean M;
     private final WorldBorder N;
     int[] H;
 
-    protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag) {
+    // CraftBukkit start Added the following
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+        @Override
+        public boolean add( BlockState blockState ) {
+            Iterator<BlockState> blockStateIterator = this.iterator();
+            while( blockStateIterator.hasNext() ) {
+                BlockState blockState1 = blockStateIterator.next();
+                if ( blockState1.getLocation().equals( blockState.getLocation() ) ) {
+                    return false;
+                }
+            }
+
+            return super.add( blockState );
+        }
+    };
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    private int tickPosition;
+
+    // Spigot start
+    private boolean guardEntityList;
+    protected final gnu.trove.map.hash.TLongShortHashMap chunkTickList;
+    protected float growthOdds = 100;
+    protected float modifiedOdds = 100;
+    private final byte chunkTickRadius;
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+    public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
+    public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
+    public java.util.ArrayDeque<BlockRedstoneTorch.RedstoneUpdateInfo> redstoneUpdateInfos; // Paper - Move from Map in BlockRedstoneTorch to here
+
+    public static long chunkToKey(int x, int z)
+    {
+        long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
+        k |= ( ( ( (long) z ) & 0xFFFF0000L ) << 32 ) | ( ( ( (long) z ) & 0x0000FFFFL ) << 16 );
+        return k;
+    }
+
+    public static int keyToX(long k)
+    {
+        return (int) ( ( ( k >> 16 ) & 0xFFFF0000 ) | ( k & 0x0000FFFF ) );
+    }
+
+    public static int keyToZ(long k)
+    {
+        return (int) ( ( ( k >> 32 ) & 0xFFFF0000L ) | ( ( k >> 16 ) & 0x0000FFFF ) );
+    }
+    // Spigot end
+
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final org.github.paperspigot.PaperSpigotWorldConfig paperSpigotConfig; // PaperSpigot
+
+    public final co.aikar.timings.WorldTimingsHandler timings; // Spigot
+    public final net.techcable.tacospigot.TacoSpigotWorldConfig tacoSpigotConfig;
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
+        this.paperSpigotConfig = new org.github.paperspigot.PaperSpigotWorldConfig( worlddata.getName() ); // PaperSpigot
+        this.tacoSpigotConfig = new net.techcable.tacospigot.TacoSpigotWorldConfig(worlddata.getName()); // TacoSpigot
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
+        // Spigot start
+        this.chunkTickRadius = (byte) ( ( this.getServer().getViewDistance() < 7 ) ? this.getServer().getViewDistance() : 7 );
+        this.chunkTickList = new gnu.trove.map.hash.TLongShortHashMap( spigotConfig.chunksPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE );
+        this.chunkTickList.setAutoCompactionFactor( 0 );
+        // Spigot end
+
         this.L = this.random.nextInt(12000);
         this.allowMonsters = true;
         this.allowAnimals = true;
@@ -67,6 +202,39 @@
         this.worldProvider = worldprovider;
         this.isClientSide = flag;
         this.N = worldprovider.getWorldBorder();
+        // CraftBukkit start
+        // Moved from PlayerList
+        this.N.a(new IWorldBorderListener() {
+            public void a(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), World.this);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), World.this);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), World.this);
+            }
+
+            public void a(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), World.this);
+            }
+
+            public void b(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), World.this);
+            }
+
+            public void b(WorldBorder worldborder, double d0) {}
+
+            public void c(WorldBorder worldborder, double d0) {}
+        });
+        this.getServer().addWorld(this.world);
+        // CraftBukkit end
+        this.keepSpawnInMemory = this.paperSpigotConfig.keepSpawnInMemory; // PaperSpigot
+        timings = new co.aikar.timings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+        this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
     }
 
     public World b() {
@@ -83,7 +251,7 @@
                 CrashReport crashreport = CrashReport.a(throwable, "Getting biome");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Coordinates of biome request");
 
-                crashreportsystemdetails.a("Location", new Callable<String>() {
+                crashreportsystemdetails.a("Location", new Callable() {
                     public String a() throws Exception {
                         return CrashReportSystemDetails.a(blockposition);
                     }
@@ -193,6 +361,27 @@
     }
 
     public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration) {
+            BlockState blockstate = null;
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    blockstate = previous;
+                    it.remove();
+                    break;
+                }
+            }
+            if (blockstate == null) {
+                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+            }
+            blockstate.setTypeId(CraftMagicNumbers.getId(iblockdata.getBlock()));
+            blockstate.setRawData((byte) iblockdata.getBlock().toLegacyData(iblockdata));
+            this.capturedBlockStates.add(blockstate);
+            return true;
+        }
+        // CraftBukkit end
         if (!this.isValidLocation(blockposition)) {
             return false;
         } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
@@ -200,9 +389,23 @@
         } else {
             Chunk chunk = this.getChunkAtWorldCoords(blockposition);
             Block block = iblockdata.getBlock();
+
+            // CraftBukkit start - capture blockstates
+            BlockState blockstate = null;
+            if (this.captureBlockStates) {
+                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+                this.capturedBlockStates.add(blockstate);
+            }
+            // CraftBukkit end
+
             IBlockData iblockdata1 = chunk.a(blockposition, iblockdata);
 
             if (iblockdata1 == null) {
+                // CraftBukkit start - remove blockstate if failed
+                if (this.captureBlockStates) {
+                    this.capturedBlockStates.remove(blockstate);
+                }
+                // CraftBukkit end
                 return false;
             } else {
                 Block block1 = iblockdata1.getBlock();
@@ -213,6 +416,7 @@
                     this.methodProfiler.b();
                 }
 
+                /*
                 if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && chunk.isReady()) {
                     this.notify(blockposition);
                 }
@@ -223,12 +427,35 @@
                         this.updateAdjacentComparators(blockposition, block);
                     }
                 }
+                */
+
+                // CraftBukkit start
+                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                    // Modularize client and physic updates
+                    notifyAndUpdatePhysics(blockposition, chunk, block1, block, i);
+                }
+                // CraftBukkit end
 
                 return true;
             }
         }
     }
 
+    // CraftBukkit start - Split off from original setTypeAndData(int i, int j, int k, Block block, int l, int i1) method in order to directly send client and physic updates
+    public void notifyAndUpdatePhysics(BlockPosition blockposition, Chunk chunk, Block oldBlock, Block newBLock, int flag) {
+        if ((flag & 2) != 0 && (chunk == null || chunk.isReady())) {  // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            this.notify(blockposition);
+        }
+
+        if (!this.isClientSide && (flag & 1) != 0) {
+            this.update(blockposition, oldBlock);
+            if (newBLock.isComplexRedstone()) {
+                this.updateAdjacentComparators(blockposition, newBLock);
+            }
+        }
+    }
+    // CraftBukkit end
+
     public boolean setAir(BlockPosition blockposition) {
         return this.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 3);
     }
@@ -262,6 +489,11 @@
 
     public void update(BlockPosition blockposition, Block block) {
         if (this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
             this.applyPhysics(blockposition, block);
         }
 
@@ -278,7 +510,7 @@
 
         if (!this.worldProvider.o()) {
             for (i1 = k; i1 <= l; ++i1) {
-                this.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+                this.updateLight(EnumSkyBlock.SKY, new BlockPosition(i, i1, j)); // PaperSpigot - Asynchronous lighting updates
             }
         }
 
@@ -303,6 +535,7 @@
         this.d(blockposition.up(), block);
         this.d(blockposition.north(), block);
         this.d(blockposition.south(), block);
+        spigotConfig.antiXrayInstance.updateNearbyBlocks(this, blockposition); // Spigot
     }
 
     public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
@@ -337,16 +570,32 @@
             IBlockData iblockdata = this.getType(blockposition);
 
             try {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer) this).getWorld();
+				// TacoSpigot start - Add config to disable redstone firing BlockPhysicsEvent 
+				if (world != null && (this.tacoSpigotConfig.isRedstoneFireBPE || !(block instanceof BlockRedstoneWire || block instanceof BlockRedstoneTorch || block instanceof BlockRepeater))) {
+				// TacoSpigot end
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
                 iblockdata.getBlock().doPhysics(this, blockposition, iblockdata, block);
+            } catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                haveWeSilencedAPhysicsCrash = true;
+                blockLocation = blockposition.getX() + ", " + blockposition.getY() + ", " + blockposition.getZ(); // Spigot End
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Exception while updating neighbours");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being updated");
 
-                crashreportsystemdetails.a("Source block type", new Callable<String>() {
+                crashreportsystemdetails.a("Source block type", new Callable() {
                     public String a() throws Exception {
                         try {
-                            return String.format("ID #%d (%s // %s)", Block.getId(block), block.a(), block.getClass().getCanonicalName());
-                        } catch (Throwable throwable1) {
+                            return String.format("ID #%d (%s // %s)", new Object[] { Integer.valueOf(Block.getId(block)), block.a(), block.getClass().getCanonicalName()});
+                        } catch (Throwable throwable) {
                             return "ID #" + Block.getId(block);
                         }
                     }
@@ -517,7 +766,25 @@
         return this.worldProvider.p()[this.getLightLevel(blockposition)];
     }
 
-    public IBlockData getType(BlockPosition blockposition) {
+    // Spigot start
+    public IBlockData getType(BlockPosition blockposition)
+    {
+        return getType( blockposition, true );
+    }
+
+    public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration && useCaptured) {
+    // Spigot end
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
+            }
+        }
+        // CraftBukkit end
         if (!this.isValidLocation(blockposition)) {
             return Blocks.AIR.getBlockData();
         } else {
@@ -723,6 +990,14 @@
     }
 
     public boolean addEntity(Entity entity) {
+        // CraftBukkit start - Used for entities other than creatures
+        return addEntity(entity, SpawnReason.DEFAULT);
+    }
+
+    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        if (entity == null) return false;
+        // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
         int j = MathHelper.floor(entity.locZ / 16.0D);
         boolean flag = entity.attachedToPlayer;
@@ -731,7 +1006,52 @@
             flag = true;
         }
 
+        // CraftBukkit start
+        org.bukkit.event.Cancellable event = null;
+        if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMonster || entity instanceof EntityGhast || entity instanceof EntitySlime;
+
+            if (spawnReason != SpawnReason.CUSTOM) {
+                if (isAnimal && !allowAnimals || isMonster && !allowMonsters) {
+                    entity.dead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
+        } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        }
+        // Spigot start
+        else if (entity instanceof EntityExperienceOrb) {
+            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityExperienceOrb) {
+                        EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
+                        if (!loopItem.dead) {
+                            xp.value += loopItem.value;
+                            loopItem.die();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.dead)) {
+            entity.dead = true;
+            return false;
+        }
+        // CraftBukkit end
+
         if (!flag && !this.isChunkLoaded(i, j, true)) {
+            entity.dead = true;
             return false;
         } else {
             if (entity instanceof EntityHuman) {
@@ -753,6 +1073,7 @@
             ((IWorldAccess) this.u.get(i)).a(entity);
         }
 
+        entity.valid = true; // CraftBukkit
     }
 
     protected void b(Entity entity) {
@@ -760,6 +1081,7 @@
             ((IWorldAccess) this.u.get(i)).b(entity);
         }
 
+        entity.valid = false; // CraftBukkit
     }
 
     public void kill(Entity entity) {
@@ -774,6 +1096,23 @@
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
+            // Spigot start
+            for ( Object o : worldMaps.c )
+            {
+                if ( o instanceof WorldMap )
+                {
+                    WorldMap map = (WorldMap) o;
+                    map.i.remove( entity );
+                    for ( Iterator<WorldMap.WorldMapHumanTracker> iter = (Iterator<WorldMap.WorldMapHumanTracker>) map.g.iterator(); iter.hasNext(); )
+                    {
+                        if ( iter.next().trackee == entity )
+                        {
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+            // Spigot end
             this.everyoneSleeping();
             this.b(entity);
         }
@@ -781,12 +1120,14 @@
     }
 
     public void removeEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.everyoneSleeping();
         }
 
+        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
         int i = entity.ae;
         int j = entity.ag;
 
@@ -794,7 +1135,16 @@
             this.getChunkAt(i, j).b(entity);
         }
 
-        this.entityList.remove(entity);
+        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        int index = this.entityList.indexOf(entity);
+        if (index != -1) {
+            if (index <= this.tickPosition) {
+                this.tickPosition--;
+            }
+            this.entityList.remove(index);
+        }
+        // CraftBukkit end
+        } // Spigot
         this.b(entity);
     }
 
@@ -816,28 +1166,72 @@
         IBlockData iblockdata = Blocks.STONE.getBlockData();
         BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
 
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = i1; l1 < j1; ++l1) {
-                if (this.isLoaded(blockposition_mutableblockposition.c(k1, 64, l1))) {
-                    for (int i2 = k - 1; i2 < l; ++i2) {
-                        blockposition_mutableblockposition.c(k1, i2, l1);
-                        if (flag && flag1) {
-                            entity.h(false);
-                        } else if (!flag && !flag1) {
-                            entity.h(true);
+        // Spigot start
+        int ystart = ( ( k - 1 ) < 0 ) ? 0 : ( k - 1 );
+        for ( int chunkx = ( i >> 4 ); chunkx <= ( ( j - 1 ) >> 4 ); chunkx++ )
+        {
+            int cx = chunkx << 4;
+            for ( int chunkz = ( i1 >> 4 ); chunkz <= ( ( j1 - 1 ) >> 4 ); chunkz++ )
+            {
+                Chunk chunk = this.getChunkIfLoaded( chunkx, chunkz );
+                if ( chunk == null )
+                    {
+                        // PaperSpigot start
+                        if (entity.loadChunks) {
+                            chunk = ((ChunkProviderServer) entity.world.chunkProvider).getChunkAt(chunkx, chunkz);
+                        } else {
+                            entity.inUnloadedChunk = true; // PaperSpigot - Remove entities in unloaded chunks
+                            continue;
                         }
+                        // PaperSpigot end
+                    }
+                int cz = chunkz << 4;
+                // Compute ranges within chunk
+                int xstart = ( i < cx ) ? cx : i;
+                int xend = ( j < ( cx + 16 ) ) ? j : ( cx + 16 );
+                int zstart = ( i1 < cz ) ? cz : i1;
+                int zend = ( j1 < ( cz + 16 ) ) ? j1 : ( cz + 16 );
+                // Loop through blocks within chunk
+                for ( int x = xstart; x < xend; x++ )
+                {
+                    for ( int z = zstart; z < zend; z++ ) {
+                        for (int y = ystart; y < l; y++) {
+                            BlockPosition blockposition = new BlockPosition(x, y, z);
+
+                            if (flag && flag1) {
+                                entity.h(false);
+                            } else if (!flag && !flag1) {
+                                entity.h(true);
+                            }
 
-                        IBlockData iblockdata1 = iblockdata;
-
-                        if (worldborder.a((BlockPosition) blockposition_mutableblockposition) || !flag1) {
-                            iblockdata1 = this.getType(blockposition_mutableblockposition);
+                            IBlockData block;
+                            if (!this.getWorldBorder().a(blockposition) && flag1) {
+                                block = Blocks.STONE.getBlockData();
+                            } else {
+                                block = chunk.getBlockData(blockposition);
+                            }
+                            if (block != null) {
+                                // PaperSpigot start - FallingBlocks and TNT collide with specific non-collidable blocks
+                                Block b = block.getBlock();
+                                if (entity.world.paperSpigotConfig.fallingBlocksCollideWithSigns && (entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && (b instanceof BlockSign || b instanceof BlockFenceGate || b instanceof BlockTorch || b instanceof BlockButtonAbstract || b instanceof BlockLever || b instanceof BlockTripwireHook || b instanceof BlockTripwire || b instanceof BlockChest || b instanceof BlockSlowSand || b instanceof BlockBed || b instanceof BlockEnderChest || b instanceof BlockEnchantmentTable || b instanceof BlockBrewingStand)) {
+                                    AxisAlignedBB aabb = AxisAlignedBB.a(x, y, z, x + 1.0, y + 1.0, z + 1.0);
+                                    if (axisalignedbb.b(aabb)) arraylist.add(aabb);
+                                } else {
+                                    b.a(this, blockposition, block, axisalignedbb, arraylist, entity);
+                                }
+                                // PaperSpigot end
+                            }
                         }
-
-                        iblockdata1.getBlock().a(this, blockposition_mutableblockposition, iblockdata1, axisalignedbb, arraylist, entity);
                     }
                 }
             }
         }
+        // Spigot end
+
+        if (entity instanceof EntityItem) return arraylist; // PaperSpigot - Optimize item movement
+        if (entity instanceof EntityArmorStand) return arraylist; // TacoSpigot - Optimize armor stand movement
+        if (entity instanceof EntityTNTPrimed) return arraylist; // TacoSpigot - Optimize tnt entity movement
+        if (entity instanceof EntityFallingBlock) return arraylist; // TacoSpigot - Optimize falling block movement
 
         double d0 = 0.25D;
         List list = this.getEntities(entity, axisalignedbb.grow(d0, d0, d0));
@@ -949,16 +1343,16 @@
         BlockPosition blockposition1;
         BlockPosition blockposition2;
 
-        for (blockposition2 = new BlockPosition(blockposition.getX(), chunk.g() + 16, blockposition.getZ()); blockposition2.getY() >= 0; blockposition2 = blockposition1) {
-            blockposition1 = blockposition2.down();
-            Material material = chunk.getType(blockposition1).getMaterial();
+        for (blockposition1 = new BlockPosition(blockposition.getX(), chunk.g() + 16, blockposition.getZ()); blockposition1.getY() >= 0; blockposition1 = blockposition2) {
+            blockposition2 = blockposition1.down();
+            Material material = chunk.getType(blockposition2).getMaterial();
 
             if (material.isSolid() && material != Material.LEAVES) {
                 break;
             }
         }
 
-        return blockposition2;
+        return blockposition1;
     }
 
     public void a(BlockPosition blockposition, Block block, int i) {}
@@ -971,13 +1365,18 @@
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
-        Entity entity;
         int i;
+        Entity entity;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
         for (i = 0; i < this.k.size(); ++i) {
             entity = (Entity) this.k.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
 
             try {
                 ++entity.ticksLived;
@@ -1000,29 +1399,43 @@
         }
 
         this.methodProfiler.c("remove");
+        timings.entityRemoval.startTiming(); // Spigot
         this.entityList.removeAll(this.g);
 
         int j;
         int k;
 
-        for (i = 0; i < this.g.size(); ++i) {
-            entity = (Entity) this.g.get(i);
-            j = entity.ae;
-            k = entity.ag;
-            if (entity.ad && this.isChunkLoaded(j, k, true)) {
-                this.getChunkAt(j, k).b(entity);
+        // Paper start - Set based removal lists
+        for (Entity e : this.g) {
+            j = e.ae;
+            k = e.ag;
+            if (e.ad && this.isChunkLoaded(j, k, true)) {
+                this.getChunkAt(j, k).b(e);
             }
         }
 
-        for (i = 0; i < this.g.size(); ++i) {
-            this.b((Entity) this.g.get(i));
+        for (Entity e : this.g) {
+            this.b(e);
         }
+        // Paper end
 
         this.g.clear();
+        timings.entityRemoval.stopTiming(); // Spigot
         this.methodProfiler.c("regular");
 
-        for (i = 0; i < this.entityList.size(); ++i) {
-            entity = (Entity) this.entityList.get(i);
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        guardEntityList = true; // Spigot
+        // CraftBukkit start - Use field for loop variable
+        co.aikar.timings.TimingHistory.entityTicks += this.entityList.size(); // Spigot
+        int entitiesThisCycle = 0;
+        // PaperSpigot start - Disable tick limiters
+        //if (tickPosition < 0) tickPosition = 0;
+        for (tickPosition = 0; tickPosition < entityList.size(); tickPosition++) {
+            // PaperSpigot end
+            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+            entity = (Entity) this.entityList.get(this.tickPosition);
+            // CraftBukkit end
             if (entity.vehicle != null) {
                 if (!entity.vehicle.dead && entity.vehicle.passenger == entity) {
                     continue;
@@ -1035,12 +1448,17 @@
             this.methodProfiler.a("tick");
             if (!entity.dead) {
                 try {
+                    entity.tickTimer.startTiming(); // Spigot
                     this.g(entity);
+                    entity.tickTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
-                    crashreport = CrashReport.a(throwable1, "Ticking entity");
-                    crashreportsystemdetails = crashreport.a("Entity being ticked");
-                    entity.appendEntityCrashDetails(crashreportsystemdetails);
-                    throw new ReportedException(crashreport);
+                    // PaperSpigot start - Prevent tile entity and entity crashes
+                    entity.tickTimer.stopTiming();
+                    System.err.println("Entity threw exception at " + entity.world.getWorld().getName() + ":" + entity.locX + "," + entity.locY + "," + entity.locZ);
+                    throwable1.printStackTrace();
+                    entity.dead = true;
+                    continue;
+                    // PaperSpigot end
                 }
             }
 
@@ -1053,51 +1471,87 @@
                     this.getChunkAt(j, k).b(entity);
                 }
 
-                this.entityList.remove(i--);
+                guardEntityList = false; // Spigot
+                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
                 this.b(entity);
             }
 
             this.methodProfiler.b();
         }
+        guardEntityList = false; // Spigot
 
+        timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
+        timings.tileEntityTick.startTiming(); // Spigot
         this.M = true;
-        Iterator iterator = this.tileEntityList.iterator();
+        // CraftBukkit start - From below, clean up tile entities before ticking them
+        if (!this.c.isEmpty()) {
+            this.tileEntityList.removeAll(this.c);
+            //this.h.removeAll(this.c); // PaperSpigot - Remove unused list
+            this.c.clear();
+        }
+        // CraftBukkit end
 
-        while (iterator.hasNext()) {
-            TileEntity tileentity = (TileEntity) iterator.next();
+        // Spigot start
+        int tilesThisCycle = 0;
+        for (tileTickPosition = 0; tileTickPosition < tileEntityList.size(); tileTickPosition++) { // PaperSpigot - Disable tick limiters
+            tileTickPosition = (tileTickPosition < tileEntityList.size()) ? tileTickPosition : 0;
+            TileEntity tileentity = (TileEntity) this.tileEntityList.get(tileTickPosition);
+            // Spigot start
+            if (tileentity == null) {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                tilesThisCycle--;
+                this.tileEntityList.remove(tileTickPosition--);
+                continue;
+            }
+            // Spigot end
 
             if (!tileentity.x() && tileentity.t()) {
                 BlockPosition blockposition = tileentity.getPosition();
 
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
+                        tileentity.tickTimer.startTiming(); // Spigot
                         ((IUpdatePlayerListBox) tileentity).c();
                     } catch (Throwable throwable2) {
-                        CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
-                        CrashReportSystemDetails crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
-
-                        tileentity.a(crashreportsystemdetails1);
-                        throw new ReportedException(crashreport1);
+                        // PaperSpigot start - Prevent tile entity and entity crashes
+                        tileentity.tickTimer.stopTiming();
+                        System.err.println("TileEntity threw exception at " + tileentity.world.getWorld().getName() + ":" + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ());
+                        throwable2.printStackTrace();
+                        tilesThisCycle--;
+                        this.tileEntityList.remove(tileTickPosition--);
+                        continue;
+                        // PaperSpigot end
+                    }
+                    // Spigot start
+                    finally {
+                        tileentity.tickTimer.stopTiming();
                     }
+                    // Spigot end
                 }
             }
 
             if (tileentity.x()) {
-                iterator.remove();
-                this.h.remove(tileentity);
+                tilesThisCycle--;
+                this.tileEntityList.remove(tileTickPosition--);
+                //this.h.remove(tileentity); // PaperSpigot - Remove unused list
                 if (this.isLoaded(tileentity.getPosition())) {
                     this.getChunkAtWorldCoords(tileentity.getPosition()).e(tileentity.getPosition());
                 }
             }
         }
 
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
+        /* CraftBukkit start - Moved up
         if (!this.c.isEmpty()) {
             this.tileEntityList.removeAll(this.c);
             this.h.removeAll(this.c);
             this.c.clear();
         }
+        // CraftBukkit end */
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
@@ -1105,9 +1559,11 @@
                 TileEntity tileentity1 = (TileEntity) this.b.get(l);
 
                 if (!tileentity1.x()) {
+                    /* CraftBukkit start - Order matters, moved down
                     if (!this.h.contains(tileentity1)) {
                         this.a(tileentity1);
                     }
+                    // CraftBukkit end */
 
                     if (this.isLoaded(tileentity1.getPosition())) {
                         this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
@@ -1120,12 +1576,15 @@
             this.b.clear();
         }
 
+        timings.tileEntityPending.stopTiming(); // Spigot
+        co.aikar.timings.TimingHistory.tileEntityTicks += this.tileEntityList.size(); // Spigot
+
         this.methodProfiler.b();
         this.methodProfiler.b();
     }
 
     public boolean a(TileEntity tileentity) {
-        boolean flag = this.h.add(tileentity);
+        boolean flag = true; // PaperSpigot - Remove unused list
 
         if (flag && tileentity instanceof IUpdatePlayerListBox) {
             this.tileEntityList.add(tileentity);
@@ -1143,7 +1602,7 @@
             while (iterator.hasNext()) {
                 TileEntity tileentity = (TileEntity) iterator.next();
 
-                this.h.add(tileentity);
+                //this.h.add(tileentity); // PaperSpigot - Remove unused list
                 if (tileentity instanceof IUpdatePlayerListBox) {
                     this.tileEntityList.add(tileentity);
                 }
@@ -1161,7 +1620,20 @@
         int j = MathHelper.floor(entity.locZ);
         byte b0 = 32;
 
-        if (!flag || this.isAreaLoaded(i - b0, 0, j - b0, i + b0, 0, j + b0, true)) {
+        // Spigot start
+        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
+            entity.ticksLived++;
+            entity.inactiveTick();
+            // PaperSpigot start - Remove entities in unloaded chunks
+            if (!this.isChunkLoaded(i, j, true) && ((entity instanceof EntityEnderPearl && this.paperSpigotConfig.removeUnloadedEnderPearls) ||
+                    (entity instanceof EntityFallingBlock && this.paperSpigotConfig.removeUnloadedFallingBlocks) ||
+                    (entity instanceof EntityTNTPrimed && this.paperSpigotConfig.removeUnloadedTNTEntities))) {
+                entity.inUnloadedChunk = true;
+                entity.die();
+            }
+            // PaperSpigot end
+        } else {
+            // CraftBukkit end
             entity.P = entity.locX;
             entity.Q = entity.locY;
             entity.R = entity.locZ;
@@ -1169,6 +1641,7 @@
             entity.lastPitch = entity.pitch;
             if (flag && entity.ad) {
                 ++entity.ticksLived;
+                ++co.aikar.timings.TimingHistory.activatedEntityTicks; // Spigot
                 if (entity.vehicle != null) {
                     entity.ak();
                 } else {
@@ -1202,6 +1675,7 @@
             int i1 = MathHelper.floor(entity.locZ / 16.0D);
 
             if (!entity.ad || entity.ae != k || entity.af != l || entity.ag != i1) {
+                if (entity.loadChunks) entity.loadChunks(); // PaperSpigot - Force load chunks
                 if (entity.ad && this.isChunkLoaded(entity.ae, entity.ag, true)) {
                     this.getChunkAt(entity.ae, entity.ag).a(entity, entity.af);
                 }
@@ -1237,6 +1711,13 @@
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
+            // PaperSpigot start - Allow block placement if the placer cannot see the vanished blocker
+            if (entity instanceof EntityPlayer && entity1 instanceof EntityPlayer) {
+                if (!((EntityPlayer) entity).getBukkitEntity().canSee(((EntityPlayer) entity1).getBukkitEntity())) {
+                    continue;
+                }
+            }
+
             if (!entity1.dead && entity1.k && entity1 != entity && (entity == null || entity.vehicle != entity1 && entity.passenger != entity1)) {
                 return false;
             }
@@ -1343,7 +1824,7 @@
                         Block block = iblockdata.getBlock();
 
                         if (block.getMaterial() == material) {
-                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.b((Integer) iblockdata.get(BlockFluids.LEVEL)));
+                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.b(((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue()));
 
                             if ((double) l >= d0) {
                                 flag = true;
@@ -1479,13 +1960,21 @@
         }
     }
 
+    public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+
     public TileEntity getTileEntity(BlockPosition blockposition) {
         if (!this.isValidLocation(blockposition)) {
             return null;
         } else {
+            // CraftBukkit start
+            if (capturedTileEntities.containsKey(blockposition)) {
+                return capturedTileEntities.get(blockposition);
+            }
+            // CraftBukkit end
+
             TileEntity tileentity = null;
-            TileEntity tileentity1;
             int i;
+            TileEntity tileentity1;
 
             if (this.M) {
                 for (i = 0; i < this.b.size(); ++i) {
@@ -1517,6 +2006,14 @@
 
     public void setTileEntity(BlockPosition blockposition, TileEntity tileentity) {
         if (tileentity != null && !tileentity.x()) {
+            // CraftBukkit start
+            if (captureBlockStates) {
+                tileentity.a(this);
+                tileentity.a(blockposition);
+                capturedTileEntities.put(blockposition, tileentity);
+                return;
+            }
+            // CraftBukkit end
             if (this.M) {
                 tileentity.a(blockposition);
                 Iterator iterator = this.b.iterator();
@@ -1530,6 +2027,7 @@
                     }
                 }
 
+                tileentity.a(this); // Spigot - No null worlds
                 this.b.add(tileentity);
             } else {
                 this.a(tileentity);
@@ -1548,7 +2046,7 @@
         } else {
             if (tileentity != null) {
                 this.b.remove(tileentity);
-                this.h.remove(tileentity);
+                //this.h.remove(tileentity); // PaperSpigot - Remove unused list
                 this.tileEntityList.remove(tileentity);
             }
 
@@ -1572,7 +2070,7 @@
         IBlockData iblockdata = iblockaccess.getType(blockposition);
         Block block = iblockdata.getBlock();
 
-        return block.getMaterial().k() && block.d() ? true : (block instanceof BlockStairs ? iblockdata.get(BlockStairs.HALF) == BlockStairs.EnumHalf.TOP : (block instanceof BlockStepAbstract ? iblockdata.get(BlockStepAbstract.HALF) == BlockStepAbstract.EnumSlabHalf.TOP : (block instanceof BlockHopper ? true : (block instanceof BlockSnow ? (Integer) iblockdata.get(BlockSnow.LAYERS) == 7 : false))));
+        return block.getMaterial().k() && block.d() ? true : (block instanceof BlockStairs ? iblockdata.get(BlockStairs.HALF) == BlockStairs.EnumHalf.TOP : (block instanceof BlockStepAbstract ? iblockdata.get(BlockStepAbstract.HALF) == BlockStepAbstract.EnumSlabHalf.TOP : (block instanceof BlockHopper ? true : (block instanceof BlockSnow ? ((Integer) iblockdata.get(BlockSnow.LAYERS)).intValue() == 7 : false))));
     }
 
     public boolean d(BlockPosition blockposition, boolean flag) {
@@ -1679,32 +2177,65 @@
                 }
 
                 this.p = MathHelper.a(this.p, 0.0F, 1.0F);
+
+                // CraftBukkit start
+                for (int idx = 0; idx < this.players.size(); ++idx) {
+                    if (((EntityPlayer) this.players.get(idx)).world == this) {
+                        ((EntityPlayer) this.players.get(idx)).tickWeather();
+                    }
+                }
+                // CraftBukkit end
             }
         }
     }
 
     protected void D() {
-        this.chunkTickList.clear();
+        // this.chunkTickList.clear(); // CraftBukkit - removed
         this.methodProfiler.a("buildList");
 
-        EntityHuman entityhuman;
         int i;
+        EntityHuman entityhuman;
         int j;
         int k;
         int l;
 
+        // Spigot start
+        int optimalChunks = spigotConfig.chunksPerTick;
+        // Quick conditions to allow us to exist early
+        if ( optimalChunks > 0  ) {
+        // Keep chunks with growth inside of the optimal chunk range
+        int chunksPerPlayer = Math.min( 200, Math.max( 1, (int) ( ( ( optimalChunks - players.size() ) / (double) players.size() ) + 0.5 ) ) );
+        int randRange = 3 + chunksPerPlayer / 30;
+        // Limit to normal tick radius - including view distance
+        randRange = ( randRange > chunkTickRadius ) ? chunkTickRadius : randRange;
+        // odds of growth happening vs growth happening in vanilla
+        this.growthOdds = this.modifiedOdds = Math.max( 35, Math.min( 100, ( ( chunksPerPlayer + 1 ) * 100F ) / 15F ) );
+        // Spigot end
         for (i = 0; i < this.players.size(); ++i) {
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX / 16.0D);
             k = MathHelper.floor(entityhuman.locZ / 16.0D);
             l = this.q();
 
-            for (int i1 = -l; i1 <= l; ++i1) {
-                for (int j1 = -l; j1 <= l; ++j1) {
-                    this.chunkTickList.add(new ChunkCoordIntPair(i1 + j, j1 + k));
+            // Spigot start - Always update the chunk the player is on
+            long key = chunkToKey( j, k );
+            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+            chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+
+            // Check and see if we update the chunks surrounding the player this tick
+            for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
+            {
+                int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
+                long hash = chunkToKey( dx + j, dz + k );
+                if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
+                {
+                    chunkTickList.put( hash, (short) -1 ); // no players
                 }
             }
         }
+            // Spigot End
+        }
 
         this.methodProfiler.b();
         if (this.L > 0) {
@@ -1712,7 +2243,7 @@
         }
 
         this.methodProfiler.a("playerCheckLight");
-        if (!this.players.isEmpty()) {
+        if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             i = this.random.nextInt(this.players.size());
             entityhuman = (EntityHuman) this.players.get(i);
             j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
@@ -1728,7 +2259,7 @@
 
     protected void a(int i, int j, Chunk chunk) {
         this.methodProfiler.c("moodSound");
-        if (this.L == 0 && !this.isClientSide) {
+        if (!this.paperSpigotConfig.disableMoodSounds && this.L == 0 && !this.isClientSide) { // PaperSpigot - Disable mood sounds
             this.m = this.m * 3 + 1013904223;
             int k = this.m >> 2;
             int l = k & 15;
@@ -1782,7 +2313,7 @@
                 IBlockData iblockdata = this.getType(blockposition);
                 Block block = iblockdata.getBlock();
 
-                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && (Integer) iblockdata.get(BlockFluids.LEVEL) == 0) {
+                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue() == 0) {
                     if (!flag) {
                         return true;
                     }
@@ -1828,10 +2359,10 @@
         boolean flag = false;
 
         if (!this.worldProvider.o()) {
-            flag |= this.c(EnumSkyBlock.SKY, blockposition);
+            flag |= this.updateLight(EnumSkyBlock.SKY, blockposition); // PaperSpigot - Asynchronous lighting updates
         }
 
-        flag |= this.c(EnumSkyBlock.BLOCK, blockposition);
+        flag |= this.updateLight(EnumSkyBlock.BLOCK, blockposition); // PaperSpigot - Asynchronous lighting updates
         return flag;
     }
 
@@ -1878,8 +2409,11 @@
         }
     }
 
-    public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
-        if (!this.areChunksLoaded(blockposition, 17, false)) {
+    public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition, Chunk chunk, List<Chunk> neighbors) { // PaperSpigot
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        //Chunk chunk = this.getChunkIfLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+        if (chunk == null /*|| !chunk.areNeighborsLoaded(1)*/ /*!this.areChunksLoaded(blockposition, 17, false)*/) {
+            // CraftBukkit end
             return false;
         } else {
             int i = 0;
@@ -1996,11 +2530,66 @@
                 }
             }
 
+            // PaperSpigot start - Asynchronous light updates
+            if (chunk.world.paperSpigotConfig.useAsyncLighting) {
+                chunk.pendingLightUpdates.decrementAndGet();
+                if (neighbors != null) {
+                    for (Chunk neighbor : neighbors) {
+                        neighbor.pendingLightUpdates.decrementAndGet();
+                    }
+                }
+            }
+            // PaperSpigot end
             this.methodProfiler.b();
             return true;
         }
     }
 
+    /**
+     * PaperSpigot - Asynchronous lighting updates
+     */
+    public boolean updateLight(final EnumSkyBlock enumskyblock, final BlockPosition position) {
+        int x = position.getX();
+        int z = position.getZ();
+        final Chunk chunk = this.getChunkIfLoaded(x >> 4, z >> 4);
+        if (chunk == null || !chunk.areNeighborsLoaded(1)) {
+            return false;
+        }
+
+        if (!chunk.world.paperSpigotConfig.useAsyncLighting) {
+            return this.c(enumskyblock, position, chunk, null);
+        }
+
+        chunk.pendingLightUpdates.incrementAndGet();
+        chunk.lightUpdateTime = chunk.world.getTime();
+
+        final List<Chunk> neighbors = new ArrayList<Chunk>();
+        for (int cx = (x >> 4) - 1; cx <= (x >> 4) + 1; ++cx) {
+            for (int cz = (z >> 4) - 1; cz <= (z >> 4) + 1; ++cz) {
+                if (cx != x >> 4 && cz != z >> 4) {
+                    Chunk neighbor = this.getChunkIfLoaded(cx, cz);
+                    if (neighbor != null) {
+                        neighbor.pendingLightUpdates.incrementAndGet();
+                        neighbor.lightUpdateTime = chunk.world.getTime();
+                        neighbors.add(neighbor);
+                    }
+                }
+            }
+        }
+
+        if (!Bukkit.isPrimaryThread()) {
+            return this.c(enumskyblock, position, chunk, neighbors);
+        }
+
+        lightingExecutor.submit(new Runnable() {
+            @Override
+            public void run() {
+                World.this.c(enumskyblock, position, chunk, neighbors);
+            }
+        });
+        return true;
+    }
+
     public boolean a(boolean flag) {
         return false;
     }
@@ -2042,7 +2631,7 @@
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
-            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply(entity)) {
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) { // CraftBukkit - fix decompile error
                 arraylist.add(entity);
             }
         }
@@ -2057,7 +2646,7 @@
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
-            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply(entity)) {
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) { // CraftBukkit - fix decompile error
                 arraylist.add(entity);
             }
         }
@@ -2105,7 +2694,7 @@
             }
         }
 
-        return entity;
+        return (T) entity; // CraftBukkit fix decompile error
     }
 
     public Entity a(int i) {
@@ -2125,8 +2714,17 @@
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityInsentient) {
+                EntityInsentient entityinsentient = (EntityInsentient) entity;
+                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                    continue;
+                }
+            }
 
-            if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+            if (oclass.isAssignableFrom(entity.getClass())) {
+            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                // CraftBukkit end
                 ++i;
             }
         }
@@ -2135,12 +2733,19 @@
     }
 
     public void b(Collection<Entity> collection) {
-        this.entityList.addAll(collection);
+        org.spigotmc.AsyncCatcher.catchOp( "entity world add"); // Spigot
+        // CraftBukkit start
+        // this.entityList.addAll(collection);
         Iterator iterator = collection.iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
+            if (entity == null) {
+                continue;
+            }
+            this.entityList.add(entity);
+            // CraftBukkit end
             this.a(entity);
         }
 
@@ -2154,7 +2759,13 @@
         Block block1 = this.getType(blockposition).getBlock();
         AxisAlignedBB axisalignedbb = flag ? null : block.a(this, blockposition, block.getBlockData());
 
-        return axisalignedbb != null && !this.a(axisalignedbb, entity) ? false : (block1.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL ? true : block1.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
+        // CraftBukkit start - store default return
+        boolean defaultReturn = axisalignedbb != null && !this.a(axisalignedbb, entity) ? false : (block1.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL ? true : block1.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+
+        return event.isBuildable();
+        // CraftBukkit end
     }
 
     public int F() {
@@ -2253,6 +2864,11 @@
 
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityhuman1 == null || entityhuman1.dead) {
+                continue;
+            }
+            // CraftBukkit end
 
             if (IEntitySelector.d.apply(entityhuman1)) {
                 double d5 = entityhuman1.e(d0, d1, d2);
@@ -2283,6 +2899,53 @@
         return false;
     }
 
+    // PaperSpigot start - Modified methods for affects spawning
+    public EntityHuman findNearbyPlayerWhoAffectsSpawning(Entity entity, double d0) {
+        return this.findNearbyPlayerWhoAffectsSpawning(entity.locX, entity.locY, entity.locZ, d0);
+    }
+
+    public EntityHuman findNearbyPlayerWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
+        double d4 = -1.0D;
+        EntityHuman entityhuman = null;
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityhuman1 == null || entityhuman1.dead || !entityhuman1.affectsSpawning) {
+                continue;
+            }
+            // CraftBukkit end
+
+            if (IEntitySelector.d.apply(entityhuman1)) {
+                double d5 = entityhuman1.e(d0, d1, d2);
+
+                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
+                    d4 = d5;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+
+        return entityhuman;
+    }
+
+    public boolean isPlayerNearbyWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+
+            if (IEntitySelector.d.apply(entityhuman)) {
+                double d4 = entityhuman.e(d0, d1, d2);
+
+                if (d3 < 0.0D || d4 < d3 * d3 && entityhuman.affectsSpawning) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+    // PaperSpigot end
+
     public EntityHuman a(String s) {
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
@@ -2369,6 +3032,16 @@
 
     public void everyoneSleeping() {}
 
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus() {
+        if (!this.isClientSide) {
+            this.everyoneSleeping();
+        }
+    }
+    // CraftBukkit end
+
     public float h(float f) {
         return (this.q + (this.r - this.q) * f) * this.j(f);
     }
@@ -2444,8 +3117,8 @@
 
             crashreportsystemdetails.a("Block coordinates", (Object) CrashReportSystemDetails.a(blockposition));
             crashreportsystemdetails.a("Event source", (Object) entityhuman);
-            crashreportsystemdetails.a("Event type", (Object) i);
-            crashreportsystemdetails.a("Event data", (Object) j);
+            crashreportsystemdetails.a("Event type", (Object) Integer.valueOf(i));
+            crashreportsystemdetails.a("Event data", (Object) Integer.valueOf(j));
             throw new ReportedException(crashreport);
         }
     }
@@ -2473,7 +3146,7 @@
         CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Affected level", 1);
 
         crashreportsystemdetails.a("Level name", (Object) (this.worldData == null ? "????" : this.worldData.getName()));
-        crashreportsystemdetails.a("All players", new Callable<String>() {
+        crashreportsystemdetails.a("All players", new Callable() {
             public String a() {
                 return World.this.players.size() + " total; " + World.this.players.toString();
             }
@@ -2482,7 +3155,7 @@
                 return this.a();
             }
         });
-        crashreportsystemdetails.a("Chunk stats", new Callable<String>() {
+        crashreportsystemdetails.a("Chunk stats", new Callable() {
             public String a() {
                 return World.this.chunkProvider.getName();
             }
@@ -2586,12 +3259,13 @@
         return this.N;
     }
 
+    public boolean shouldStayLoaded(int i, int j) { return this.c(i, j);}
     public boolean c(int i, int j) {
         BlockPosition blockposition = this.getSpawn();
         int k = i * 16 + 8 - blockposition.getX();
         int l = j * 16 + 8 - blockposition.getZ();
         short short0 = 128;
 
-        return k >= -short0 && k <= short0 && l >= -short0 && l <= short0;
+        return k >= -short0 && k <= short0 && l >= -short0 && l <= short0 && this.keepSpawnInMemory; // CraftBukkit - Added 'this.keepSpawnInMemory'
     }
 }
