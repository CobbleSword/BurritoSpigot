--- PlayerConnection.java
+++ PlayerConnection.java
@@ -73,24 +117,60 @@
     private int f;
     private int g;
     private boolean h;
-    private int keepAliveID;
-    private long lastPing;
+    private int i;
+    private long j;
     private long k;
-    private int chatThrottle;
+    // CraftBukkit start - multithreaded fields
+    private volatile int chatThrottle;
+    private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
+    // CraftBukkit end
     private int m;
-    private IntHashMap<Short> n = new IntHashMap<>();
+    private IntHashMap<Short> n = new IntHashMap();
     private double o;
     private double p;
     private double q;
     private boolean checkMovement = true;
+    private boolean processedDisconnect; // CraftBukkit - added
+    private int lastBookTick = 0;
+    private int creativeSlotCount = 0;
+    private int windowClickCount = 0;
+    private long lastCustomPayloadPacketTS = -1L;
+    private boolean isExploiter = false;
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
         this.networkManager = networkmanager;
+
+        this.lastBookTick = MinecraftServer.currentTick;
         networkmanager.a((PacketListener) this);
         this.player = entityplayer;
         entityplayer.playerConnection = this;
+
+        // CraftBukkit start - add fields and methods
+        this.server = minecraftserver.server;
+    }
+
+    private final org.bukkit.craftbukkit.CraftServer server;
+    private int lastTick = MinecraftServer.currentTick;
+    private int lastDropTick = MinecraftServer.currentTick;
+    private int dropCount = MinecraftServer.currentTick;
+    private static final int SURVIVAL_PLACE_DISTANCE_SQUARED = 6 * 6;
+    private static final int CREATIVE_PLACE_DISTANCE_SQUARED = 7 * 7;
+
+    // Get position of last block hit for BlockDamageLevel.STOPPED
+    private double lastPosX = Double.MAX_VALUE;
+    private double lastPosY = Double.MAX_VALUE;
+    private double lastPosZ = Double.MAX_VALUE;
+    private float lastPitch = Float.MAX_VALUE;
+    private float lastYaw = Float.MAX_VALUE;
+    private boolean justTeleported = false;
+    private boolean hasMoved; // Spigot
+
+    public CraftPlayer getPlayer() {
+        return (this.player == null) ? null : (CraftPlayer) this.player.getBukkitEntity();
     }
+    private final static HashSet<Integer> invalidItems = new HashSet<Integer>(java.util.Arrays.asList(8, 9, 10, 11, 26, 34, 36, 43, 51, 52, 55, 59, 60, 62, 63, 64, 68, 71, 74, 75, 83, 90, 92, 93, 94, 104, 105, 115, 117, 118, 119, 125, 127, 132, 140, 141, 142, 144)); // TODO: Check after every update.
+    // CraftBukkit end
 
     public void c() {
         this.h = false;
@@ -98,44 +178,69 @@
         this.minecraftServer.methodProfiler.a("keepAlive");
         if ((long) this.e - this.k > 40L) {
             this.k = (long) this.e;
-            this.lastPing = this.getCurrentMillis();
-            this.keepAliveID = (int) this.lastPing;
-            this.sendPacket(new PacketPlayOutKeepAlive(this.keepAliveID));
+            this.j = this.d();
+            this.i = (int) this.j;
+            this.sendPacket(new PacketPlayOutKeepAlive(this.i));
         }
 
         this.minecraftServer.methodProfiler.b();
+        // CraftBukkit start
+        for (int spam; (spam = this.chatThrottle) > 0 && !chatSpamField.compareAndSet(this, spam, spam - 1); ) ;
+        /* Use thread-safe field access instead
         if (this.chatThrottle > 0) {
             --this.chatThrottle;
         }
+        */
+        // CraftBukkit end
 
         if (this.m > 0) {
             --this.m;
         }
 
         if (this.player.D() > 0L && this.minecraftServer.getIdleTimeout() > 0 && MinecraftServer.az() - this.player.D() > (long) (this.minecraftServer.getIdleTimeout() * 1000 * 60)) {
+            this.player.resetIdleTimer(); // CraftBukkit - SPIGOT-854
             this.disconnect("You have been idle for too long!");
         }
 
     }
 
-    public NetworkManager getNetworkManager() {
+    public NetworkManager a() {
         return this.networkManager;
     }
 
+    //No called of force closed
     public void disconnect(String s) {
+        // CraftBukkit start - fire PlayerKickEvent
+        String leaveMessage = EnumChatFormat.YELLOW + this.player.getName() + " left the game.";
+
+        PlayerKickEvent event = new PlayerKickEvent(this.server.getPlayer(this.player), s, leaveMessage);
+
+        if (this.server.getServer().isRunning()) {
+            this.server.getPluginManager().callEvent(event);
+        }
+
+        if (event.isCancelled()) {
+            // Do not kick the player
+            return;
+        }
+        // Send the possibly modified leave message
+        s = event.getReason();
+        // CraftBukkit end
         final ChatComponentText chatcomponenttext = new ChatComponentText(s);
 
-        this.networkManager.a(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener<Future<? super Void>>() {
-            public void operationComplete(Future<? super Void> future) throws Exception {
+        this.networkManager.a(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener() {
+            public void operationComplete(Future future) throws Exception { // CraftBukkit - fix decompile error
                 PlayerConnection.this.networkManager.close(chatcomponenttext);
             }
-        });
+        }, new GenericFutureListener[0]);
+        this.a(chatcomponenttext); // CraftBukkit - fire quit instantly
         this.networkManager.k();
-        Futures.getUnchecked(this.minecraftServer.postToMainThread(new Runnable() {
-            public void run() {
-                PlayerConnection.this.networkManager.l();
+        // CraftBukkit - Don't wait
+        this.minecraftServer.postToMainThread(new Runnable() {
+             public void run() {
+                 PlayerConnection.this.networkManager.l();
             }
-        }));
+        });
     }
 
     public void a(PacketPlayInSteerVehicle packetplayinsteervehicle) {
@@ -1868,25 +2947,41 @@
     }
 
     public void a(PacketPlayInKeepAlive packetplayinkeepalive) {
-        if (packetplayinkeepalive.a() == this.keepAliveID) {
-            int i = (int) (this.getCurrentMillis() - this.lastPing);
+        if (packetplayinkeepalive.a() == this.i) {
+            int i = (int) (this.d() - this.j);
 
             this.player.ping = (this.player.ping * 3 + i) / 4;
         }
 
     }
 
-    private long getCurrentMillis() {
+    private long d() {
         return System.nanoTime() / 1000000L;
     }
 
     public void a(PacketPlayInAbilities packetplayinabilities) {
         PlayerConnectionUtils.ensureMainThread(packetplayinabilities, this, this.player.u());
-        this.player.abilities.isFlying = packetplayinabilities.isFlying() && this.player.abilities.canFly;
+        // CraftBukkit start
+        if (this.player.abilities.canFly && this.player.abilities.isFlying != packetplayinabilities.isFlying()) {
+            PlayerToggleFlightEvent event = new PlayerToggleFlightEvent(this.server.getPlayer(this.player), packetplayinabilities.isFlying());
+            this.server.getPluginManager().callEvent(event);
+            if (!event.isCancelled()) {
+                this.player.abilities.isFlying = packetplayinabilities.isFlying(); // Actually set the player's flying status
+            } else {
+                this.player.updateAbilities(); // Tell the player their ability was reverted
+            }
+        }
+        // CraftBukkit end
     }
 
     public void a(PacketPlayInTabComplete packetplayintabcomplete) {
         PlayerConnectionUtils.ensureMainThread(packetplayintabcomplete, this, this.player.u());
+        // CraftBukkit start
+        if (chatSpamField.addAndGet(this, 10) > 500 && !this.minecraftServer.getPlayerList().isOp(this.player.getProfile())) {
+            this.disconnect("disconnect.spam");
+            return;
+        }
+        // CraftBukkit end
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.minecraftServer.tabCompleteCommand(this.player, packetplayintabcomplete.a(), packetplayintabcomplete.b()).iterator();
 
